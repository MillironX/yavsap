/*
====================================================================================

    MillironX/jev-analysis-pipeline Nextflow config file

====================================================================================

    Default config options for all compute environments

------------------------------------------------------------------------------------
*/

// Process metadata
manifest {
    name              = 'MillironX/jev-analysis-pipeline'
    author            = 'Thomas A. Christensen II'
    homePage          = 'https://github.com/MillironX/jev-analysis-pipeline'
    description       = 'Intra-sample viral population analysis targeted at Japanese Encephalitis'
    mainScript        = 'main.nf'
    nextflowVersion    = '!>=21.04.0'
    version           = '0.0.1'
    recurseSubmodules = true
}

// Global default parameters
params {

    // Input options
    input          = '.'
    sra            = false
    platform       = ''
    pe             = (params.platform == 'pe'  || params.platform == 'illumina')
    ont            = (params.platform == 'ont' || params.platform == 'nanopore')

    // Reference genome options
    genome         = 'NC_001437.1' // JEV RefSeq

    // Kraken 2 options
    kraken2_db     = ''
    keep_taxid     = '0 10239' // 0 = Unclassified, 10239 = Viral

    // Read trimming options (shared)
    trim_minlen      = (params.pe) ? 100 : 300
    trim_winsize     = (params.pe) ? 50 : 250
    trim_winqual     = (params.pe) ? 15 : 90

    // Illumina trimming options (Trimmomatic)
    trim_adapters    = 'NexteraPE-PE.fa'
    trim_mismatches  = 2
    trim_pclip       = 30
    trim_clip        = 10
    trim_leading     = 15
    trim_trailing    = 15
    trim_crop        = 0
    trim_headcrop    = 0

    // ONT-specific trimming options (Filtlong)
    trim_keep_percent = 90
    trim_target_bases = 500000000

    // Canu ONT assembly options
    canu_corrected_error_rate = 0.144
    canu_min_read_length      = 1000
    canu_min_overlap_length   = params.canu_min_read_length / 2
    canu_stop_on_low_coverage = 10

    // SPAdes Illumina assembly options
    spades_mode = 'rnaviral'

    // Haplotyping options
    haplotype_significance = 0.05
    haplotype_minimum      = 10

    // Boilerplate options
    outdir           = './results'
    tracedir         = "${params.outdir}/.trace"
    publish_dir_mode = 'copy'
    help             = false

    // Max resource options
    // Defaults only, expecting to be overwritten
    max_memory                   = '750.GB'
    max_cpus                     = 72
    max_time                     = '240.h'

    // Step-skipping options
    skip_filtering    = false
    skip_assembly     = false
    skip_haplotype    = false
}

// Configuration profiles for
profiles {
    debug { process.beforeScript = 'echo $HOSTNAME' }
    docker {
        docker.enabled         = true
        docker.userEmulation   = true
        docker.runOptions      = "-v ${params.kraken2_db}:${params.kraken2_db}:ro"
        singularity.enabled    = false
        podman.enabled         = false
        shifter.enabled        = false
        charliecloud.enabled   = false
        envWhitelist           = 'KRAKEN2_DEFAULT_DB,KRAKEN2_DB_PATH'
    }
    singularity {
        singularity.enabled    = true
        singularity.autoMounts = true
        singularity.runOptions = "--bind ${params.kraken2_db}"
        docker.enabled         = false
        podman.enabled         = false
        shifter.enabled        = false
        charliecloud.enabled   = false
        envWhitelist           = 'KRAKEN2_DEFAULT_DB,KRAKEN2_DB_PATH'
    }
    podman {
        podman.enabled         = true
        podman.runOptions      = "-v ${params.kraken2_db}:${params.kraken2_db}:ro,z"
        podman.mountFlags      = 'z'
        docker.enabled         = false
        singularity.enabled    = false
        shifter.enabled        = false
        charliecloud.enabled   = false
        envWhitelist           = 'KRAKEN2_DEFAULT_DB,KRAKEN2_DB_PATH'
    }
    test { includeConfig 'conf/test.config' }
}

process {
// Per-process container environments
// Listed alphabetical, by the tool suite's name
    withLabel: bam_readcount {
        container = 'docker.io/mgibio/bam-readcount:latest'
    }
    withLabel: canu {
        container = 'quay.io/staphb/canu:2.1.1'
    }
    withLabel: cliquesnv {
        container = 'quay.io/biocontainers/cliquesnv:2.0.2--hdfd78af_0'
    }
    withLabel: edirect {
        container = 'docker.io/ncbi/edirect:12.5'
    }
    withLabel: filtlong {
        container = 'quay.io/staphb/filtlong:0.2.1'
    }
    withLabel: ivar {
        container = 'quay.io/staphb/ivar:1.3'
    }
    withLabel: julia {
        conda     = 'conda-forge::julia=1.6.2'
    }
    withLabel: kraken {
        container = 'quay.io/staphb/kraken2:2.1.2-no-db'
    }
    withLabel: krakentools {
        conda     = 'bioconda::krakentools=1.2'
    }
    withLabel: mafft {
        container = 'quay.io/staphb/mafft:7.475'
    }
    withLabel: minimap {
        container = 'docker.io/niemasd/minimap2_samtools:2.22_1.12'
    }
    withLabel: multiqc {
        container = 'docker.io/ewels/multiqc:v1.11'
    }
    withLabel: raxml {
        container = 'docker.io/evolbioinfo/raxml-ng:v1.0.3'
    }
    withLabel: samtools {
        container = 'quay.io/staphb/samtools:1.12'
    }
    withLabel: seqret {
        conda     = 'bioconda::emboss=6.6.0'
    }
    withLabel: spades {
        container = 'quay.io/staphb/spades:3.15.2'
    }
    withLabel: trimmomatic {
        container = 'quay.io/staphb/trimmomatic:0.39'
    }

    withLabel: run_local {
        executor = 'local'
    }
}

includeConfig 'conf/base.config'

// Enable smart process tracing
def trace_timestamp = new java.util.Date().format( 'yyyy-MM-dd_HH-mm-ss')
timeline {
    enabled = true
    file    = "${params.tracedir}/execution_timeline_${trace_timestamp}.html"
}
report {
    enabled = true
    file    = "${params.tracedir}/execution_report_${trace_timestamp}.html"
}
trace {
    enabled = true
    file    = "${params.tracedir}/execution_trace_${trace_timestamp}.txt"
}
dag {
    enabled = true
    file    = "${params.tracedir}/pipeline_dag_${trace_timestamp}.svg"
}

env {
    KRAKEN2_DEFAULT_DB = "${params.kraken2_db}"
    KRAKEN2_DB_PATH    = "${params.kraken2_db}"
}

// Capture exit codes from upstream processes when piping
process.shell = ['/bin/bash', '-euo', 'pipefail']

// Function to ensure that resource requirements don't go beyond
// a maximum limit
def check_max(obj, type) {
    if (type == 'memory') {
        try {
            if (obj.compareTo(params.max_memory as nextflow.util.MemoryUnit) == 1)
                return params.max_memory as nextflow.util.MemoryUnit
            else
                return obj
        } catch (all) {
            println "   ### ERROR ###   Max memory '${params.max_memory}' is not valid! Using default value: $obj"
            return obj
        }
    } else if (type == 'time') {
        try {
            if (obj.compareTo(params.max_time as nextflow.util.Duration) == 1)
                return params.max_time as nextflow.util.Duration
            else
                return obj
        } catch (all) {
            println "   ### ERROR ###   Max time '${params.max_time}' is not valid! Using default value: $obj"
            return obj
        }
    } else if (type == 'cpus') {
        try {
            return Math.min( obj, params.max_cpus as int )
        } catch (all) {
            println "   ### ERROR ###   Max cpus '${params.max_cpus}' is not valid! Using default value: $obj"
            return obj
        }
    }
}
