#!/bin/bash
# -*- mode: julia -*-
#=
julia --project="$(realpath "$(dirname "${BASH_SOURCE[0]}")")" -e 'using Pkg; Pkg.instantiate()'
exec julia --project="$(realpath "$(dirname "${BASH_SOURCE[0]}")")" "${BASH_SOURCE[0]}" "$@"
=#
# Searches for variant calls that can be verified using long NGS reads

# Import packages
using BioAlignments
using BioSymbols
using Combinatorics
using CSV
using DataFrames
using GenomicFeatures
using XAM

# Bring in the function definitions
include("jev-function-lib.jl")

# Parse the arguments
bamfile = ARGS[1]
varfile = ARGS[2]

# Find the index file
baifile = string(bamfile, ".bai")
if !isfile(baifile)
    baifile = replace(bamfile, ".bam" => ".bai")
    if !isfile(baifile)
        error("Could not find index file for BAM file")
    end
end

# Read in the variant calls
variantdata = DataFrame(CSV.File(varfile))

# Parse the variants
variants = Variant.(eachrow(variantdata))

# Find all possible pairings of these variants
variantcombos = collect(combinations(variants, 2))

# Import reads from the BAM file
reader = open(BAM.Reader, bamfile, index=baifile)

# Find the reads that match every possible combo
for variantpair in variantcombos
    # Set up variant combo counts
    ref_ref = 0
    ref_alt = 0
    alt_ref = 0
    alt_alt = 0

    # Get the reads that contain the first variant position
    containingreads = collect(eachoverlap(reader, variantpair[1].region, variantpair[1].position:variantpair[1].position))

    # Get the reads that contain the second variant position
    containingreads = containingreads[BAM.rightposition.(containingreads) .>= variantpair[2].position]

    # Check every NGS read that contains both positions
    for record in containingreads
        # Find this read's basecalls for both locations
        try
            base1 = baseatreferenceposition(record, variantpair[1].position)
            base2 = baseatreferenceposition(record, variantpair[2].position)

            # Print out the intermediate results
            println(BAM.tempname(record), ":")
            println("    ",
                variantpair[1].position, ",", variantpair[2].position,
                " REF1:", variantpair[1].referencebase,
                " REF2:", variantpair[2].referencebase,
                " ALT1:", variantpair[1].alternatebase,
                " ALT2:", variantpair[2].alternatebase,
                " READ1:", base1,
                " READ2:", base2)
        catch e
            @warn "Base out of bounds" record e
            base1 = DNA_Gap
            base2 = DNA_Gap
        end #try
    end #for
end #for

close(reader)
