#!/bin/bash
# -*- mode: julia -*-
#=
julia --project="$(realpath "$(dirname "${BASH_SOURCE[0]}")")" -e 'using Pkg; Pkg.instantiate()'
exec julia --project="$(realpath "$(dirname "${BASH_SOURCE[0]}")")" "${BASH_SOURCE[0]}" "$@"
=#
# Searches for variant calls that can be verified using long NGS reads

# Import packages
using BioAlignments
using BioSymbols
using Combinatorics
using CSV
using DataFrames
using GenomicFeatures
using XAM

# Bring in the function definitions
include("jev-function-lib.jl")
using BioSequences

# Parse the arguments
bamfile = ARGS[1]
varfile = ARGS[2]
outfile = ARGS[3]

# Find the index file
baifile = string(bamfile, ".bai")
if !isfile(baifile)
    baifile = replace(bamfile, ".bam" => ".bai")
    if !isfile(baifile)
        error("Could not find index file for BAM file")
    end
end

# Read in the variant calls
variantdata = DataFrame(CSV.File(varfile))

# Parse the variants
variants = Variant.(eachrow(variantdata))
# Find all possible pairings of these variants
variantcombos = collect(combinations(variants, 2))

# Import reads from the BAM file
reader = open(BAM.Reader, bamfile, index=baifile)

# Declare an empty dataframe for the possible combinations
variantcombodata = DataFrame(
    Variant1 = Int[],
    Variant2 = Int[],
    Reference_Reference = Int[],
    Reference_Alternate = Int[],
    Alternate_Reference = Int[],
    Alternate_Alternate = Int[]
)


# Find the reads that match every possible combo
for variantpair in variantcombos
    # Set up variant combo counts
    ref_ref = 0
    ref_alt = 0
    alt_ref = 0
    alt_alt = 0

    # Get the reads that contain the first variant position
    containingreads = collect(eachoverlap(reader, variantpair[1].region, variantpair[1].position:variantpair[1].position))

    # Get the reads that contain the second variant position
    containingreads = containingreads[BAM.rightposition.(containingreads) .>= variantpair[2].position]

    # Check every NGS read that contains both positions
    for record in containingreads
        # Find this read's basecalls for both locations
        try
            base1 = baseatreferenceposition(record, variantpair[1].position)
            base2 = baseatreferenceposition(record, variantpair[2].position)

            # Find how the basecalls stack up
            match1 = matchvariant(base1, variantpair[1])
            match2 = matchvariant(base2, variantpair[2])

            # Find which combination we're dealing with, if any
            if     match1 == :reference && match2 == :reference
                ref_ref += 1
            elseif match1 == :reference && match2 == :alternate
                ref_alt += 1
            elseif match1 == :alternate && match2 == :reference
                alt_ref += 1
            elseif match1 == :alternate && match2 == :alternate
                alt_alt += 1
            end

            # Print out the intermediate results
            println(BAM.tempname(record), ":")
            println("    ",
                variantpair[1].position, ",", variantpair[2].position,
                " REF1:", variantpair[1].referencebase,
                " REF2:", variantpair[2].referencebase,
                " ALT1:", variantpair[1].alternatebase,
                " ALT2:", variantpair[2].alternatebase,
                " READ1:", base1,
                " READ2:", base2)
        catch e
            @warn "Base out of bounds" record e
        end #try
    end #for

    # Write which combos we have to the overall dataframe
    if sum([ref_ref, alt_ref, ref_alt, alt_alt]) > 0
        push!(variantcombodata, [variantpair[1].position, variantpair[2].position, ref_ref, ref_alt, alt_ref, alt_alt])
    end #if
end #for
close(reader)

CSV.write(outfile, variantcombodata)
