#!/bin/bash
# -*- mode: julia -*-
#=
julia --project="$(realpath "$(dirname "${BASH_SOURCE[0]}")")" -e 'using Pkg; Pkg.instantiate()'
exec julia --project="$(realpath "$(dirname "${BASH_SOURCE[0]}")")" "${BASH_SOURCE[0]}" "$@"
=#
# Searches for variant calls that can be verified using long NGS reads

# Import packages
using BioAlignments
using BioSymbols
using Combinatorics
using CSV
using DataFrames
using GenomicFeatures
using XAM

# Bring in the function definitions
include("jev-function-lib.jl")
using BioSequences

# Parse the arguments
bamfile = ARGS[1]
varfile = ARGS[2]
outfile = ARGS[3]

# Find the index file
baifile = string(bamfile, ".bai")
if !isfile(baifile)
    baifile = replace(bamfile, ".bam" => ".bai")
    if !isfile(baifile)
        error("Could not find index file for BAM file")
    end
end

# Read in the variant calls
variantdata = DataFrame(CSV.File(varfile))

# Parse the variants
variants = Variant.(eachrow(variantdata))
# Find all possible pairings of these variants
variantcombos = collect(combinations(variants, 2))

# Import reads from the BAM file
reader = open(BAM.Reader, bamfile, index=baifile)

# Declare an empty dataframe for the possible combinations
snpcombodata = DataFrame(
    Variant1 = Int[],
    Variant2 = Int[],
    Reference_Reference = Int[],
    Reference_Alternate = Int[],
    Alternate_Reference = Int[],
    Alternate_Alternate = Int[]
)


# Find the reads that match every possible combo
for variantpair in variantcombos
    # Set up variant combo counts
    ref_ref = 0
    ref_alt = 0
    alt_ref = 0
    alt_alt = 0

    # Get the reads that contain the first variant position
    containingreads = collect(eachoverlap(reader, variantpair[1].region, variantpair[1].position:variantpair[1].position))

    # Get the reads that contain the second variant position
    containingreads = containingreads[BAM.rightposition.(containingreads) .>= variantpair[2].position]

    # Check every NGS read that contains both positions
    for record in containingreads
        # Find this read's basecalls for both locations
        try
            base1 = baseatreferenceposition(record, variantpair[1].position)
            base2 = baseatreferenceposition(record, variantpair[2].position)

                    # Find the reference basecall for these locations
                    ref1base = refseq[var1loc]
                    ref2base = refseq[var2loc]

                    # Find the alternate basecall for these locations
                    alt1base = LongDNASeq(loc1alt)[1]
                    alt2base = LongDNASeq(loc2alt)[1]

                    # Find which combination we're dealing with, if any
                    if loc1base == ref1base && loc2base == ref2base
                        ref_ref += 1
                    elseif loc1base == ref1base && loc2base == alt2base
                        ref_alt += 1
                    elseif loc1base == alt2base && loc2base == ref2base
                        alt_ref += 1
                    elseif loc1base == alt2base && loc2base == alt2base
                        alt_alt += 1
                    end

            # Print out the intermediate results
            println(BAM.tempname(record), ":")
            println("    ",
                variantpair[1].position, ",", variantpair[2].position,
                " REF1:", variantpair[1].referencebase,
                " REF2:", variantpair[2].referencebase,
                " ALT1:", variantpair[1].alternatebase,
                " ALT2:", variantpair[2].alternatebase,
                " READ1:", base1,
                " READ2:", base2)
        catch e
            @warn "Base out of bounds" record e
            base1 = DNA_Gap
            base2 = DNA_Gap
        end #try
    end #for
end #for

    # Write which combos we have to the overall dataframe
    push!(snpcombodata, [var1loc, var2loc, ref_ref, ref_alt, alt_ref, alt_alt])

close(reader)


CSV.write(outfile, snpcombodata)