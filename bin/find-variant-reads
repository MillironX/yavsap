#!/bin/bash
# -*- mode: julia -*-
#=
julia --project="$(realpath "$(dirname "${BASH_SOURCE[0]}")")" -e 'using Pkg; Pkg.instantiate()'
exec julia --project="$(realpath "$(dirname "${BASH_SOURCE[0]}")")" "${BASH_SOURCE[0]}" "$@"
=#
# Searches for variant calls that can be verified using long NGS reads

# Import packages
using CSV
using DataFrames
using XAM
using Combinatorics
using BioSymbols
using FASTX
using BioAlignments
using BioSequences

# Parse the arguments
bamfile = ARGS[1]
varfile = ARGS[2]
reffile = ARGS[3]
outfile = ARGS[4]

# Find the index file
baifile = string(bamfile, ".bai")
if !isfile(baifile)
    baifile = replace(bamfile, ".bam" => ".bai")
    if !isfile(baifile)
        error("Could not find index file for BAM file")
    end
end

# Read in the reference sequence
refreader = open(FASTA.Reader, reffile)
refrecord = read(refreader)
refseq = sequence(refrecord)
close(refreader)

# Read in the variant calls
snps = DataFrame(CSV.File(varfile))

# Find all possible pairings of these variants
snpcombos = collect(combinations(snps.POS,2))

# Declare an empty dataframe for the possible combinations
snpcombodata = DataFrame(
    Variant1 = Int[],
    Variant2 = Int[],
    Reference_Reference = Int[],
    Reference_Alternate = Int[],
    Alternate_Reference = Int[],
    Alternate_Alternate = Int[]
)

# Find the reads that match every possible combo
for (var1loc, var2loc) in snpcombos
    # Skip any variants that occur at the same locations
    if var1loc == var2loc
        continue
    end

    # Find the reference and variant basecalls
    var1 = snps[snps.POS .== var1loc, :]
    var2 = snps[snps.POS .== var2loc, :]
    loc1ref = var1.REF[1]
    loc2ref = var2.REF[1]
    loc1alt = var1.ALT[1]
    loc2alt = var2.ALT[1]

    # Set up variant combo counts
    ref_ref = 0
    ref_alt = 0
    alt_ref = 0
    alt_alt = 0

    # Import reads from the BAM file
    reader = open(BAM.Reader, bamfile, index=baifile)

    # Check every NGS read
    for record in reader
        # Skip the record if it is not aligned
        if BAM.ismapped(record)
            # Find the read's position on the reference
            readspan = BAM.position(record):BAM.rightposition(record)

            # Check if this read flanks the variants
            if var1loc in readspan && var2loc in readspan
                # Pull the aligned sequences for this read
                alnseq = AlignedSequence(refseq, BAM.alignment(record))

                # Find the alignment status at this position
                st1 = ref2seq(alnseq, var1loc)
                st2 = ref2seq(alnseq, var2loc)

                if st1[2] == OP_MATCH && st2[2] == OP_MATCH
                    # Workaround for weird super-short reads
                    if st2[1] >= length(BAM.sequence(record))
                        continue
                    end

                    # Find this read's basecalls for both locations
                    loc1base = BAM.sequence(record)[st1[1]]
                    loc2base = BAM.sequence(record)[st2[1]]

                    # Find the reference basecall for these locations
                    ref1base = refseq[var1loc]
                    ref2base = refseq[var2loc]

                    # Find the alternate basecall for these locations
                    alt1base = LongDNASeq(loc1alt)[1]
                    alt2base = LongDNASeq(loc2alt)[1]

                    # Find which combination we're dealing with, if any
                    if loc1base == ref1base && loc2base == ref2base
                        ref_ref += 1
                    elseif loc1base == ref1base && loc2base == alt2base
                        ref_alt += 1
                    elseif loc1base == alt2base && loc2base == ref2base
                        alt_ref += 1
                    elseif loc1base == alt2base && loc2base == alt2base
                        alt_alt += 1
                    end

                    # Print out the intermediate results
                    println(BAM.tempname(record), ":")
                    println("    ", var1loc, ",", var2loc, " REF1:", loc1ref, " REF2:", loc2ref, " ALT1:", loc1alt, " ALT2:", loc2alt, " READ1:", loc1base, " READ2:", loc2base)

                end
            end
        end

    end

    # Write which combos we have to the overall dataframe
    push!(snpcombodata, [var1loc, var2loc, ref_ref, ref_alt, alt_ref, alt_alt])

    close(reader)

end

CSV.write(outfile, snpcombodata)
