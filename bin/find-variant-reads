#!/bin/bash
#=
julia --project="$(realpath "$(dirname "${BASH_SOURCE[0]}")")" -e 'using Pkg; Pkg.instantiate()'
exec julia --project="$(realpath "$(dirname "${BASH_SOURCE[0]}")")" "${BASH_SOURCE[0]}" "$@"
=#
# Searches for variant calls that can be verified using long NGS reads

# Import packages
using CSV
using DataFrames
using XAM
using Combinatorics
using BioSymbols
using FASTX
using BioAlignments

# Parse the arguments
bamfile = ARGS[1]
varfile = ARGS[2]
reffile = ARGS[3]

# Find the index file
baifile = string(bamfile, ".bai")
if !isfile(baifile)
    baifile = replace(bamfile, ".bam" => ".bai")
    if !isfile(baifile)
        error("Could not find index file for BAM file")
    end
end

# Read in the reference sequence
refreader = open(FASTA.Reader, reffile)
refrecord = read(refreader)
refseq = sequence(refrecord)
close(refreader)

# Read in the variant calls
snps = DataFrame(CSV.File(varfile))

# IVar calls weird things, so we will only consider variants that have a p-value of less
# than 10^-5 and a frequency greater than 20%
filter!(:PVAL => p -> p < 1e-5, snps)
filter!(:ALT_FREQ => f -> f > 0.2, snps)

# Find all possible pairings of these variants
snpcombos = collect(combinations(snps.POS,2))

# Find the reads that match every possible combo
for (var1loc, var2loc) in snpcombos
    # Find the reference and variant basecalls
    var1 = snps[snps.POS .== var1loc, :]
    var2 = snps[snps.POS .== var2loc, :]
    loc1ref = var1.REF[1]
    loc2ref = var2.REF[1]
    loc1alt = var1.ALT[1]
    loc2alt = var2.ALT[1]

    # Set up variant combo counts
    ref_ref = 0
    ref_alt = 0
    alt_ref = 0
    alt_alt = 0

    # Import reads from the BAM file
    reader = open(BAM.Reader, bamfile, index=baifile)

    # Check every NGS read
    for record in reader
        # Skip the record if it is not aligned
        if BAM.ismapped(record)
            # Find the read's position on the reference
            readspan = BAM.position(record):BAM.rightposition(record)

            # Check if this read flanks the variants
            if var1loc in readspan && var2loc in readspan
                # Pull the aligned sequences for this read
                alnseq = AlignedSequence(refseq, BAM.alignment(record))

                # Find the alignment status at this position
                st1 = ref2seq(alnseq, var1loc)
                st2 = ref2seq(alnseq, var2loc)

                if st1[2] != OP_DELETE && st2[2] != OP_DELETE
                    # Find this read's basecalls for both locations
                    loc1base = BAM.sequence(record)[st1[1]]
                    loc2base = BAM.sequence(record)[st2[1]]

                    # Print out the intermediate results
                    println(BAM.tempname(record), ":")
                    println("    ", var1loc, ",", var2loc, " REF1:", loc1ref, " REF2:", loc2ref, " ALT1:", loc1alt, " ALT2:", loc2alt, " READ1:", loc1base, " READ2:", loc2base)
                end
            end
        end

    end

    close(reader)

end
